## Solution1
``` java
class Solution {
    private int maxDiameter = 0;    // member variable to keep track of max diameter
    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return maxDiameter;
    }
    private int dfs(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftDepth = dfs(root.left);  // get the left subtree depth for the current node
        int rightDepth = dfs(root.right);  // get the right subtree depth for the current node
        maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);  // update maxDiameter if necessary
        return Math.max(leftDepth, rightDepth) + 1;  // return a deeper height to last call 
    }
}
```

## note
* time O(n) space O(h)
* The idea is to traverse each node and get their sum of left subtree depth and right subtree depth and update our maxDiamete
if sum is greater than current max diameter. 
