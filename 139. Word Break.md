## Solution1 (dp bottom-up)
``` java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        
        for (int i = 1; i < dp.length; i++) {
            String cur = s.substring(0, i);
            for (int j = 1; j <= i; j++) {
                if (dp[i - j] && wordDict.contains(s.substring(i - j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[dp.length - 1];
    }
}
```
## note
* dp solution bottom up: a substring can break into words in dictionary only if at some point in this substring, the 
substring of this current substring is breakable and after that point to the end of the current substring is within 
our dictionary
* Time O(n^3) Space O(n)

## Solution2 (dfs faster) 
``` java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<Integer> visited = new HashSet<>();
        Set<String> words = new HashSet<>(wordDict);
        return dfs(s, 0, visited, words);
    }
    private boolean dfs(String s, int index, Set<Integer> visited, Set<String> wordDict) {
        if (index == s.length()) return true;
        if (visited.contains(index)) return false;
        // recursion
        for (int i = index + 1; i <= s.length(); i++) {
            if (wordDict.contains(s.substring(index, i))) {
                if (dfs(s, i, visited, wordDict))
                    return true;
                else {
                    visited.add(i);
                }
            }
        }
        visited.add(index);
        return false;
    }
}
```
* time O(n^2) space O(n)
