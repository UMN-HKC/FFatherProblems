电面：如果只用返回一个结果怎么做？

## Solution1 (BFS)
``` java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        List<String> res = new ArrayList<>();
        Set<String> set = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.offer(s);
        boolean found = false;
        
        while (!queue.isEmpty()) {
            int size = queue.size();    // this makes our program only checking the current level even though queue is not empty 
            for (int i = 0; i < size; i++) {    // only polling strings at this level
                s = queue.poll();
                if (isValidParentheses(s)) {  // check parenthesis validity in here
                    found = true;
                    res.add(s);       // we don't have to check string uniqueness, since it's handled in the next for loop
                }
                if (found) {
                    continue;
                }
                for (int j = 0; j < s.length(); j++) {
                    if (s.charAt(j) != '(' && s.charAt(j) != ')') continue;
                    String str = s.substring(0, j) + s.substring(j + 1);
                    if (!set.contains(str)) {   // only checking uniqueness, checking validity is handled before the loop
                        queue.offer(str);
                        set.add(str);
                    }
                }
            }
        }
        return res;
    }
    private boolean isValidParentheses(String s) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            // have to use two if statements to check '(' and ')' because there might be letters 
            if (s.charAt(i) == '(') count++;
            if (s.charAt(i) == ')') count--;
            if (count < 0) {
                return false;
            }
        } 
        return count == 0;
    }
}
```

## note
* Time complexity O(n * 2^n). Regarding the time complexity, I think one way we can think about the search space is as a power
subset of the original string. So it includes all possible substrings from 0 character to N(number of chars in the input string) characters. So the possibilities are 2^n. (we either pick a character or don't pick it) For each subset we check if it is a valid string so it becomes n*(2^n)
* use bfs to check each level of the parentheses string. In each level, if found valid parentheses, we loop through this 
level until the queue storing current level is empty and return the result. Otherwise, we remove one parentheses and 
put all possible parenthesis of that length into our queue.
* For parentheses to be valid, after looping through it, the counter should be zero (+1 for '(' and -1 for ')')
* Inside the while loop, we should nest our for-loop of adding next level to the queue inside another for-loop which is iterating through the current level. In this for loop, we will add a flag before the nested for loop. So, if in this level, 
we have found the valid parentheses, we will only go through the rest of the queue and not adding next level into our queue.
